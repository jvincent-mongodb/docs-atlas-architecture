.. _arch-center-resiliency:

===================================
Application and Database Resiliency
===================================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: onecol

MongoDB |service| is a modern, highly-performant database that is purpose-built 
to maintain uptime regardless of infrastructure outages, system maintenance and more.

{+service+} Features and Best Practices for Resiliency
------------------------------------------------------

Database Replication
~~~~~~~~~~~~~~~~~~~~

|service| {+clusters+} consist of a minimum of three nodes and can be increased 
to any odd number of nodes you require. Data from your application is first written 
to a primary node, and that data is then incrementally replicated and stored on 
all secondary nodes within your cluster.

By default, {+cluster+} nodes are distributed across availability zones within 
one of your chosen cloud provider's availability regions. For example, if your 
cluster is deployed to the cloud provider region ``us-east``, |service| deploys 
nodes to ``us-east-a``, ``us-east-b`` and ``us-east-c`` by default. 

Self-Healing Deployments
````````````````````````

|service| {+clusters+} must consist of an odd number of nodes, because only one 
node can be elected as the primary node to and from which your application writes 
and reads directly. 

In the event that a primary node is unavailable, because of infrastructure 
outages, maintenance windows or any other reason, |service| {+clusters+} self-heal by 
converting an existing secondary node into your primary node to maintain 
database availability. 

Maintenance Window Uptime
`````````````````````````

|service| maintains uptime during scheduled maintenance by applying updates in 
a rolling fashion to one node at a time. During this process, |service| elects a new 
primary when necessary just as it does during any other unplanned primary node 
outage.  

Monitoring
~~~~~~~~~~

|service| provides `built-in tools <https://www.mongodb.com/docs/atlas/monitoring-alerts/>`__ to monitor cluster performance, query performance 
and more. Additionally, |service| integrates easily with `third-party services <https://www.mongodb.com/docs/atlas/tutorial/third-party-service-integrations/#std-label-third-party-integrations>`__. 

Building Resilient Applications with {+service+}
------------------------------------------------

.. include:: /includes/cloud-docs/cluster-resilience.rst

Connecting Your Application to |service|
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We recommend that you use the most `current driver version <https://www.mongodb.com/docs/drivers/>`__ for your application's 
programming language whenever possible. And while the default connection string 
|service| provides is a good place to start, you might want to tune it for 
performance in the context of your specific application and deployment 
architecture. `Tuning your connection pool settings <https://www.mongodb.com/docs/manual/tutorial/connection-pool-performance-tuning/>`__ 
is particularly important in the context of enterprise level application deployments. 

Connection Pool Considerations for Performant Applications
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Opening database client connections is one of the most resource intensive processes
involved in maintaining a client connection pool that facilitates application access 
to your |service| {+cluster+}. 

Because of this, it is worth thinking about how and when you would like this 
process of opening client connections to unfold in the context of your specific 
application. 

For example, if you are scaling your |service| {+cluster+} to meet user demand, 
consider what the minimum pool size of connections your application will 
consisently need, so that when the connection pool scales the additional 
networking and compute load that comes with opening new client connections 
doesn't undermine your application's time-sensitive need for increased 
database operations. 

Min and Max Conection Pool Size 
```````````````````````````````

If your ``minPoolSize`` and ``maxPoolSize`` values are similar, the majority of your 
database client connections will open at application startup. In turn, the 
additional networking load that comes with opening such connections will happen 
at the same time. However, if there is a large range in size between your 
minimum and maximum pool size, additional connections are opened more frequestly 
during application runtime. 

This process of incrementally increasing your connection pool size during 
application runtime distributes the total workload of connecting clients from 
your application to |service| over a longer period of time, which often makes it 
manageable for a given use case, but it is important to note that the associated 
increase in network load occurs during application runtime, which has 
the potential to impact perceived database - and by extension - application 
performance for end-users.

Your application's architecture is central to this consideration. If, for example, 
you deploy your application as microservices in an elastic environment, consider 
which services should call |service| directly as a means of controlling the 
dynamic expansion and contraction of your connection pool. 

Optimizing Request Configurations for Distinct Query Types
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Query Timeout
`````````````
Almost invariably, workload-specific queries from your application will vary in 
terms of the amount of time they take to execute in |service| and in terms of 
the amount of time your application can wait for a response. 

Consider defining query classes that handle categories or buckets of similar 
request requirements. For example, you can define a query category with a fast 
timeout for end-user driven requests, a middle tier timeout bucket for general 
purpose requests, and a long-running query class for things like analytics 
queries that require the most time to execute in |service|. 

`Query timeout <https://www.mongodb.com/docs/manual/tutorial/query-documents/specify-query-timeout/>`__ behavior can be set globally in |service| and it can be defined 
at the query level. 

Retryable Database Reads and Writes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

|service| supports `retryable read <https://www.mongodb.com/docs/manual/core/retryable-reads/>`__ and `retryable write <https://www.mongodb.com/docs/manual/core/retryable-writes/>`__ operations. When enabled, 
read and write operations are retried once as a safeguard against intermittent 
network outages. 

Configure Read and Write Concerns 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

|service| {+clusters+} eventually replicate all data across all nodes. However, 
you can configure the number of nodes across which data must be repicated before 
a read or write operation is reported to have been successful. `Read concerns <https://www.mongodb.com/docs/manual/reference/read-concern/>`__ and 
`write concerns <https://www.mongodb.com/docs/manual/reference/write-concern/>`__ can be defined globally in |service| and they can be defined at the 
client level in the connection string. 

Examples
--------

The following examples <perform this action> using |service|
:ref:`tools for automation <arch-center-automation>`.

These examples also apply other recommended configurations, including:

.. tabs::

   .. tab:: Dev and Test Environments
      :tabid: devtest

      .. include:: /includes/shared-settings-clusters-devtest.rst

   .. tab:: Staging and Prod Environments
      :tabid: stagingprod

      .. include:: /includes/shared-settings-clusters-stagingprod.rst

.. tabs::

   .. tab:: CLI
      :tabid: cli

      Content here

   .. tab:: Terraform
      :tabid: Terraform

      Content here

